# üìã User Stories - Dashboard Scadenze

## üéØ Obiettivo
Creare una dashboard iniziale che mostri agli utenti le loro scadenze. Queste scadenze sono dei questionari che devono essere compilati dall'utente o da un agente incaricato dall'utente. Devono esserci i questionari in scadenza nelle prossime 4 settimane e le remediation uscite da ogni singolo questionario.

## üë• Ruoli Utente
- **Utenti**: possono vedere solo i fornitori assegnati a loro
- **Agenti**: lavorano su fornitori assegnati ad utenti per certificare i questionari e pianificare visite ispettive
- **Fornitori**: possono vedere solo i loro questionari
- **Supervisori**: vedono tutto
- **Amministratori**: vedono tutto e configurano l'applicazione

## üîß Vincoli Tecnici
- Dashboard responsive e mobile-friendly
- Utilizzare Storybook Remira: https://storybook.remira.com
- Librerie: `@remira/ucpaccelerator_unified_utils": "0.1.263"`, `@remira/unifiedui": "1.0.239"`
- Autenticazione con Keycloak (gi√† implementata)
- Autorizzazione con RBAC (gi√† implementata)
- Applicazione √® un micro frontend
- Paginazione per performance
- Sistema di alert personalizzabili

---

## üìñ User Stories

### #1 - Visualizzazione questionari in scadenza (Utente) - DONE ‚úÖ
**Come** utente  
**Voglio** visualizzare i questionari dei miei fornitori assegnati in scadenza nelle prossime 4 settimane  
**Cos√¨ da** non perdere deadline importanti e sollecitare i fornitori o bloccarli

**Acceptance Criteria:**
- ‚úÖ Vedo solo questionari dei fornitori a me assegnati
- ‚úÖ Le scadenze sono filtrate per le prossime 4 settimane dalla data corrente
- ‚úÖ Per ogni questionario vedo: nome attore della rete, tipo questionario, data scadenza, stato
- ‚úÖ I questionari sono ordinati per data scadenza (pi√π urgenti primi)
- ‚úÖ La dashboard √® responsive e mobile-friendly

**Edge Cases:** 
- Utente senza fornitori assegnati
- Questionari gi√† scaduti
- Problemi di connessione

**Implementazione Backend:**
- **API:** `GET /api/dashboard/questionnaires`
- **Handler MediatR:** `GetUpcomingQuestionnairesQuery` + `GetUpcomingQuestionnairesQueryHandler`
- **DTO:** `UpcomingQuestionnaireDto`, `GetUpcomingQuestionnairesRequest`

**Implementazione Frontend:**
- **Componente:** `DashboardQuestionnaires` usando componenti UnifiedUI
- **Pagina:** Integrazione in dashboard principale
- **Test:** Unit test componente + integration test API

---

### #2 - Visualizzazione remediation attive (Utente)
**Come** utente  
**Voglio** visualizzare le remediation aperte associate ai questionari dei miei fornitori  
**Cos√¨ da** monitorare le azioni correttive in corso e le loro scadenze

**Acceptance Criteria:**
- ‚úÖ Vedo solo remediation dei fornitori a me assegnati
- ‚úÖ Per ogni remediation vedo: attore della rete, descrizione, data scadenza, responsabile
- ‚úÖ Le remediation sono ordinate per scadenza
- ‚úÖ Posso distinguere remediation scadute da quelle ancora valide

**Edge Cases:**
- Remediation senza scadenza
- Remediation gi√† chiuse ma mostrate per errore
- Remediation senza responsabile assegnato

**Implementazione Backend:**
- **API:** `GET /api/dashboard/remediations`
- **Handler MediatR:** `GetActiveRemediationsQuery` + `GetActiveRemediationsQueryHandler`
- **DTO:** `ActiveRemediationDto`, `GetActiveRemediationsRequest`

**Implementazione Frontend:**
- **Componente:** `DashboardRemediations`
- **Test:** Unit test + integration test

---

### #3 - Dashboard agente per pianificazione visite
**Come** agente  
**Voglio** visualizzare questionari e remediation dei fornitori assegnati agli utenti per cui lavoro  
**Cos√¨ da** pianificare le visite ispettive in base alle priorit√† e scadenze

**Acceptance Criteria:**
- ‚úÖ Vedo questionari di tutti i fornitori degli utenti per cui sono incaricato
- ‚úÖ Posso filtrare per utente specifico
- ‚úÖ Vedo remediation che richiedono riverifica da parte mia
- ‚úÖ Posso marcare visite ispettive come pianificate

**Edge Cases:**
- Agente senza utenti assegnati
- Conflitti di pianificazione visite
- Utenti con molti fornitori

**Implementazione Backend:**
- **API:** `GET /api/dashboard/agent-overview`
- **Handler MediatR:** `GetAgentDashboardQuery` + `GetAgentDashboardQueryHandler`
- **DTO:** `AgentDashboardDto`, `GetAgentDashboardRequest`

**Implementazione Frontend:**
- **Componente:** `AgentDashboard`
- **Funzionalit√†:** Filtri, pianificazione visite
- **Test:** Unit test + integration test

---

### #4 - Dashboard attore della rete (self-service)
**Come** attore della rete di fornitura  
**Voglio** visualizzare i miei questionari in scadenza e le remediation da gestire  
**Cos√¨ da** completare i questionari in tempo e risolvere le non conformit√†

**Acceptance Criteria:**
- ‚úÖ Vedo solo i miei questionari e remediation
- ‚úÖ Posso accedere direttamente alla compilazione questionari
- ‚úÖ Vedo lo stato delle mie remediation (aperte/chiuse)
- ‚úÖ Posso caricare documenti per le remediation

**Edge Cases:**
- Attore della rete senza questionari assegnati
- Questionari in bozza vs pubblicati
- Remediation senza documenti richiesti

**Implementazione Backend:**
- **API:** `GET /api/dashboard/supply-network-overview`
- **Handler MediatR:** `GetSupplyNetworkDashboardQuery` + `GetSupplyNetworkDashboardQueryHandler`
- **DTO:** `SupplyNetworkDashboardDto`

**Implementazione Frontend:**
- **Componente:** `SupplyNetworkDashboard`
- **Funzionalit√†:** Link diretti a questionari, upload documenti
- **Test:** Unit test + integration test

---

### #5 - Vista supervisore/amministratore
**Come** supervisore/amministratore  
**Voglio** avere una vista globale di tutti i questionari e remediation  
**Cos√¨ da** monitorare lo stato generale di compliance

**Acceptance Criteria:**
- ‚úÖ Vedo tutti i questionari in scadenza di tutti i fornitori
- ‚úÖ Posso filtrare per utente, agente, attore della rete
- ‚úÖ Vedo statistiche aggregate (% completion, remediation aperte, ecc.)
- ‚úÖ Posso esportare report

**Edge Cases:**
- Grandi volumi di dati
- Filtri multipli complessi
- Performance con molti utenti

**Implementazione Backend:**
- **API:** `GET /api/dashboard/admin-overview`
- **Handler MediatR:** `GetAdminDashboardQuery` + `GetAdminDashboardQueryHandler`
- **DTO:** `AdminDashboardDto`, `DashboardStatsDto`

**Implementazione Frontend:**
- **Componente:** `AdminDashboard`
- **Funzionalit√†:** Filtri avanzati, statistiche, export
- **Test:** Unit test + integration test

---

### #6 - Paginazione e performance
**Come** qualsiasi utente  
**Voglio** che la dashboard carichi velocemente anche con molti dati  
**Cos√¨ da** avere un'esperienza fluida

**Acceptance Criteria:**
- ‚úÖ Paginazione per liste con pi√π di 20 elementi
- ‚úÖ Caricamento progressivo (lazy loading)
- ‚úÖ Indicatori di caricamento
- ‚úÖ Caching intelligente dei dati

**Edge Cases:**
- Connessione lenta
- Grandi dataset
- Refresh frequenti

**Implementazione Backend:**
- **Paginazione:** Implementare `PagedResult<T>` in tutti i query
- **Caching:** Response caching per dati poco volatili
- **Performance:** Indici database, query ottimizzate

**Implementazione Frontend:**
- **Componenti:** Integrazione con componenti paginazione UnifiedUI
- **Loading:** Skeleton loading, progressive enhancement
- **Caching:** React Query per client-side caching

---

### #7 - Sistema di alert personalizzabili
**Come** utente/agente  
**Voglio** impostare alert personalizzati per scadenze imminenti  
**Cos√¨ da** ricevere notifiche proattive

**Acceptance Criteria:**
- ‚úÖ Posso impostare alert per scadenze (es. 1 settimana prima)
- ‚úÖ Posso configurare tipo di notifica (email, in-app, push)
- ‚úÖ Alert diversi per questionari vs remediation
- ‚úÖ Posso disabilitare/modificare alert esistenti

**Edge Cases:**
- Alert multipli per stesso evento
- Utente senza email configurata
- Fuso orario diverso

**Implementazione Backend:**
- **API:** `POST/PUT /api/user-preferences/alerts`, `GET /api/user-preferences/alerts`
- **Handler MediatR:** `CreateUserAlertCommand`, `UpdateUserAlertCommand`, `GetUserAlertsQuery`
- **DTO:** `UserAlertDto`, `CreateUserAlertRequest`, `UpdateUserAlertRequest`
- **Background Service:** Job per invio notifiche

**Implementazione Frontend:**
- **Componente:** `AlertSettings`, `AlertNotification`
- **Funzionalit√†:** CRUD alert, preferenze notifiche
- **Test:** Unit test + integration test

---

## üéØ Riepilogo Implementazione

### Backend (.NET Core + MediatR)
- **Nuovi endpoint:** 7 API principali
- **Handlers:** 10+ Command/Query handlers
- **DTO:** 15+ oggetti di trasferimento dati
- **Background Services:** 1 per gestione alert
- **Test:** Unit test per ogni handler + integration test

### Frontend (React + TypeScript)
- **Componenti principali:** 7 componenti dashboard
- **Pagine:** 1 pagina dashboard principale con routing per ruoli
- **Utilities:** Gestione stati, caching, notifiche
- **Test:** Unit test per ogni componente + integration test

### Database
- **Nuove tabelle:** UserAlerts, DashboardPreferences (se necessarie)
- **Indici:** Ottimizzazione query per performance
- **Migrazioni:** Script di aggiornamento schema

### Priorit√† Implementazione
1. **#1** - Visualizzazione questionari utente (base)
2. **#2** - Visualizzazione remediation utente
3. **#6** - Paginazione e performance
4. **#3** - Dashboard agente
5. **#4** - Dashboard attore della rete
6. **#5** - Vista supervisore/admin
7. **#7** - Sistema alert

---

## üìù Note per l'implementazione
- Utilizzare sempre MediatR per separazione logica
- Componenti UnifiedUI per coerenza visiva
- Test-Driven Development (TDD)
- Responsive design mobile-first
- Autorizzazione RBAC su ogni endpoint
- Logging e monitoraggio per troubleshooting
- Documentazione API con Swagger
